### Game 游戏主体
定义画面尺寸，渲染引擎，场景挂载

### World 世界
游戏范围，人物和摄影机的游戏范围

### Camera 相机
视觉对画面的跟踪

### Scene 场景

定义游戏舞台，素材载入

### Sprite 物件
定义游戏物件

### Image/图像

图像与精灵的不同主要在于，Image没有动画（Animation）组件，消耗更小。 但图像也有输入事件、物理体，可以应用补间动画，可以滚动，所以只要你不使用动画，那么就应该用Image代替精灵。图像常用于显示静态图像，比如logo，背景，布景等没有动画（Animation）的元素。（在Phaser2中，Image的操控项更少，尤其是没有物理属性。） 注意：Tween（补间运动/补间动画）不同于动画（Animation）。

### Group 群组
批量操作多个物件

Group是一个抽象分组，便于批量地生成、排布、控制、循环处理近似游戏对象。与Container不同，它自身没有没有显隐、缩放、定位、旋转属性（但可以快速控制子项的这些属性）。他对子项不是独占的，子项可以存在于多个组中。因此Container更适于把多个显示对象集合成一个复合型显示对象，以便整体地控制显示状态；Group则适合于对近似对象进行批量操作。

组的一个重要用途是对象池。

### Animations 动画系统

### Physics 物理引擎


### Shape/几何图形及其子类
Shape是Phaser3新增的游戏对象。Shape本身不能加到场景上，而是用作下列几何图形游戏对象的基类：

Arc弧形
Curve曲线形
Ellipse椭圆（包括正圆）
Grid栅格
IsoBox等距(isometric)方体
IsoTriangle等距三角体（四面体）
Line线条（包括三角形、梯形）
Polygon多边形
Rectangle方形
Start星形
Triangle三角形
这些Shape子类，可以加入场景、组和容器中。你可以像处理其他常见游戏对象一样处理它们，比如应用补间动画、缩放、打开输入和物理属性。Shape通常支持填充色和笔触色。

Shape拥有常规游戏对象的所有特性，不同之处在于它有高效的渲染方式。Shape不需要使用纹理，但又可以利用WebGL中的批处理的好处，所以能很方便地在游戏中快速渲染形状。它不仅没有Graphics的高消耗问题，甚至有些Shape子类比Sprite还要快。

### Graphics/几何图画
Graphics主要用于绘制一些几何形状（比如方形、圆形、多边形、直线、弧线、曲线），最终构成一个几何图画。 Graphics初始的时候是空的，需要制定笔触色、填充色，然后用路径绘制，最后笔触着色、填充。有些常见形状，比如方形，可以方便地绘制。

在Canvas和WebGL两种模式中，Graphics的渲染是不同的。在Canvas下是绘制路径，在WebGL下是绘制多边形。这两种方式都很消耗资源，尤其是图画复杂的时候。所以，如果你的几何图画不会变化，或者变化少，你应该用Phaser.GameObjects.Graphics#generateTexture把几何图画“备份”成一个纹理，并把它返回用于生成精灵Sprite或者其他游戏对象。请注意你的几何图画的复杂程度和数量。

### Container容器
一个游戏对象加入容器后，即从显示列表中删除，而加入容器内部的显示列表，由容器负责它的渲染；位置也是相对于容器位置而言的。

容器可以嵌套。

容器可以添加遮罩或作为遮罩，但是子项不能添加遮罩，即遮罩不能叠加。

容器可以添加输入，但是因为它没有纹理，所以你必须提供一个shape作为点击区域。容器的子项也能添加输入，并独立于容器。

容器可以赋予物理体。不过，如果子项也有物理属性，并且容器或任何前辈对象不是位于0x0位置的话，那么你可能碰到意外的结果，比如物理体偏置。不把带物理属性的子项考虑进来，是因为需要过多的运算。

要注意容器带来的额外问题。嵌套越深，消耗越会升级，尤其是在输入事件上。尽可能避免使用。